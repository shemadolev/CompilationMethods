%{
    #include <iostream>
    #include "part2_helpers.hpp"
    #include "code_class.hpp"
    using namespace std;

    extern int yylex();
    void yyerror(const char*);

    extern int yylineno;
    extern const char* yytext;

    ParserNode *parseTree; 
    codeClass code;
    VarScopeTable *varScopeTable;
%}

// Reserved words 
%token  INT
        FLOAT
        VOID
        WRITE
        READ
        WHILE
        DO
        IF
        RETURN
        FULL_WHILE
        BREAK

// Solve dangling else (select shift over reduce)  
%precedence THEN
%precedence ELSE

// Other tokens (no special precedence)
%token ID INTEGERNUM REALNUM STR

//Associativity & precedence matched to C++ syntax
%right ASSIGN
%left OR
%left AND
%left RELOP
%left ADDOP
%left MULOP
%right NOT

// Symbols (Highest priority)
%precedence '(' ')' '{' '}' '.' ';' ',' ':'

%%

program : fdefs                         {parseTree=new NodeSymbol("PROGRAM",$1);}
;

fdefs : /* epsilon */                   {$$=new NodeSymbol("FDEFS", EPSILON);}
	| fdefs func_api M blk            {
                $$=new NodeSymbol("FDEFS",concatList(concatList($1,$2),$3));
        }
        | fdefs func_api ';'            {$$=new NodeSymbol("FDEFS",concatList(concatList($1,$2),$3));}
;

func_api : type ID '(' func_args ')'    {$$=new NodeSymbol("FUNC_API",concatList(concatList(concatList(concatList($1,$2),$3),$4),$5));} 
;

func_args : func_arglist                {$$=new NodeSymbol("FUNC_ARGS",$1);}       
            | /* epsilon */             {$$=new NodeSymbol("FUNC_ARGS", EPSILON);}
;

func_arglist :  func_arglist ',' dcl    {$$=new NodeSymbol("FUNC_ARGLIST",concatList(concatList($1,$2),$3));} 
                | dcl                   {$$=new NodeSymbol("FUNC_ARGLIST",$1);}
;

blk : '{' stlist '}'                    {$$=new NodeSymbol("BLK",concatList(concatList($1,$2),$3));} 
;

dcl :   ID ':' type                     {$$=new NodeSymbol("DCL",concatList(concatList($1,$2),$3));}
        | ID ',' dcl                    {$$=new NodeSymbol("DCL",concatList(concatList($1,$2),$3));}
;

type :  INT                             {$$=new NodeSymbol("TYPE",$1);}
        | FLOAT                         {$$=new NodeSymbol("TYPE",$1);}
        | VOID                          {$$=new NodeSymbol("TYPE",$1);} 
;

stlist : stlist stmt                    {$$=new NodeSymbol("STLIST",concatList($1,$2));}
         |/* epsilon */                 {$$=new NodeSymbol("STLIST", EPSILON);}
;

stmt :  dcl ';'                         {$$=new NodeSymbol("STMT",concatList($1,$2));}
        | assn                          {$$=new NodeSymbol("STMT",$1);}
        | exp ';'                       {$$=new NodeSymbol("STMT",concatList($1,$2));}
        | cntrl                         {$$=new NodeSymbol("STMT",$1);}
        | read                          {$$=new NodeSymbol("STMT",$1);}
        | write                         {$$=new NodeSymbol("STMT",$1);}
        | return                        {$$=new NodeSymbol("STMT",$1);}
        | blk                           {$$=new NodeSymbol("STMT",$1);}
        | BREAK ';'                     {$$=new NodeSymbol("STMT",concatList($1,$2));}
;

return : RETURN exp ';'                 {$$=new NodeSymbol("RETURN",concatList(concatList($1,$2),$3));}
        | RETURN ';'                    {$$=new NodeSymbol("RETURN",concatList($1,$2));}
;

write : WRITE '(' exp ')' ';'           {$$=new NodeSymbol("WRITE",concatList(concatList(concatList(concatList($1,$2),$3),$4),$5));} 
        | WRITE '(' STR ')' ';'         {$$=new NodeSymbol("WRITE",concatList(concatList(concatList(concatList($1,$2),$3),$4),$5));} 
;

read : READ '(' lval ')' ';'            {$$=new NodeSymbol("READ",concatList(concatList(concatList(concatList($1,$2),$3),$4),$5));} 
;

assn : lval ASSIGN exp ';'              {$$=new NodeSymbol("ASSN",concatList(concatList(concatList($1,$2),$3),$4));} 
;

lval : ID                               {$$=new NodeSymbol("LVAL",$1);}
;

fullwhile : FULL_WHILE N M bexp DO M stmt {
                NodeBexp *fullwhile = $$;
                NodeMarkerN *N = $2;
                NodeMarkerM *M1 = $3;
                NodeBexp *bexp = $4;
                NodeMarkerM *M2 = $6;
                NodeStatement *stmt = $7;

                fullwhile = new NodeBexp("FULLWHILE",concatList(concatList(concatList($1,$2),$3),$4));

                code->emit(string("UJUMP ") + M1->quad);
                code->backpatch(N->nextlist,code->nextQuad());
                string res = varScopeTable->newTemp(eINT);
                code->emit(string("COPYI ") + res + string(" 0"));
                code->emit(string("UJUMP ") + M1->quad);
                code->backpatch(bexp->truelist,code->nextQuad());
                code->emit(string("COPYI ") + res + string(" 1"));
                code->emit(string("UJUMP ") + M2->quad);
                code->backpatch(bexp->falselist,code->nextQuad());
                fullwhile->falselist = CodeLineList(code->nextQuad());
                fullwhile->falselist.merge(stmt.breaklist);
                code->emit(string("BREQZ ") + res + string(" -1"));
                fullwhile->truelist = CodeLineList(code->nextQuad());
                code->emit("UJUMP -1");
                code->backpatch(stmt->nextlist,M1->quad);
        } 
;

cntrl : IF bexp THEN M stmt N ELSE M stmt     {
                $$=new NodeStatement("CNTRL",concatList(concatList(concatList(concatList(concatList($1,$2),$3),$4),$5),$6));
                NodeBexp *bexp = $2;
                NodeBexp *M1 = $4;
                NodeBexp *stmt1 = $5;
                NodeBexp *N = $6;
                NodeBexp *M2 = $8;
                NodeBexp *stmt2 = $9;

                //...
        } 
        | IF bexp THEN M stmt             {
                $$=new NodeStatement("CNTRL",concatList(concatList(concatList($1,$2),$3),$4));
                //...
        } 
        | WHILE M bexp DO M stmt            {
                $$=new NodeStatement("CNTRL",concatList(concatList(concatList($1,$2),$3),$4));
                //...
        } 
        | fullwhile                     {$$=new NodeStatement("CNTRL",$1);}
;

bexp :  bexp OR M bexp                    {$$=new NodeBexp("BEXP",concatList(concatList($1,$2),$3));}
        | bexp AND M bexp                 {$$=new NodeBexp("BEXP",concatList(concatList($1,$2),$3));}
        | NOT bexp                      {$$=new NodeBexp("BEXP",concatList($1,$2));}
        | exp RELOP exp                 {$$=new NodeBexp("BEXP",concatList(concatList($1,$2),$3));}
        | '(' bexp ')'                  {$$=new NodeBexp("BEXP",concatList(concatList($1,$2),$3));}
        | fullwhile                     {$$=new NodeBexp("BEXP",$1);}
;

exp :   exp ADDOP exp 	                {$$=new NodeSymbol("EXP",concatList(concatList($1,$2),$3));}
        | exp MULOP exp                 {$$=new NodeSymbol("EXP",concatList(concatList($1,$2),$3));}
        | '(' exp ')'                   {$$=new NodeSymbol("EXP",concatList(concatList($1,$2),$3));}
        | '(' type ')' exp              {$$=new NodeSymbol("EXP",concatList(concatList(concatList($1,$2),$3),$4));}
        | ID                            {$$=new NodeSymbol("EXP",$1);}
        | num                           {$$=new NodeSymbol("EXP",$1);}
        | call                          {$$=new NodeSymbol("EXP",$1);}
;

num :   INTEGERNUM                      {$$=new NodeSymbol("NUM",$1);}
        | REALNUM                       {$$=new NodeSymbol("NUM",$1);}
;

call : ID '(' call_args ')'             {
        $$=new NodeSymbol("CALL",concatList(concatList(concatList($1,$2),$3),$4));
        //...
        varScopeTable->storeIds();
        //Back FP
        //Pass arguments to function
        //...
        varScopeTable->loadIds();
        //...

        }
;

call_args : call_arglist                {$$=new NodeSymbol("CALL_ARGS",$1);}
            |/* epsilon */              {$$=new NodeSymbol("CALL_ARGS", EPSILON);} 
;

call_arglist :  call_arglist ',' exp    {
                $$=new NodeArgsList("CALL_ARGLIST",concatList(concatList($1,$2),$3));
                $$->argsList = $1->argsList;
                $$->argsList.push_back(exp);
        }
        | exp                           {
                $$=new NodeArgsList("CALL_ARGLIST",$1);
                $$->argsList.push_back(exp);
        }
;

M : /*epsilon*/                         {$$=new NodeMarkerM();}
;

N : /*epsilon*/                         {$$=new NodeMarkerN();}
;

%%

void yyerror(const char*) {
    cout << "Syntax error: '" << yytext << "' in line number " << yylineno << endl;
    exit(2);
}
