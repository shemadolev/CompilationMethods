%{
    #include <iostream>
    #include "part3_helpers.hpp"
    #include <list>
    using namespace std;

    extern int yylex();
    void yyerror(const char*);
    void unexpected_error(const char*);
    void semantic_error(const char* err);


    extern int yylineno;
    extern const char* yytext;

    ParserNode *parseTree; 
    CodeClass code;
    VariableTable varTable;
    FunctionTable funcTable;
    
    //return address pointer
    #define RA "I0"
    //frame start pointer
    #define FP "I1"
    //stack pointer (next write pointer in stack)
    #define SP "I2"
    //return int type
    #define RT_I "I3"
    //declaration pointer
    #define DP "I4"
    //return float type
    #define RT_F "F0"

%}

// Reserved words 
%token  INT
        FLOAT
        VOID
        WRITE
        READ
        WHILE
        DO
        IF
        RETURN
        FULL_WHILE
        BREAK

// Solve dangling else (select shift over reduce)  
%precedence THEN
%precedence ELSE


// Other tokens (no special precedence)
%token ID INTEGERNUM REALNUM STR

//Associativity & precedence matched to C++ syntax
%right ASSIGN
%left OR
%left AND
%left RELOP
%left ADDOP
%left MULOP
%right NOT

// Symbols (Highest priority)
%precedence '(' ')' '{' '}' '.' ';' ',' ':'

%%

program : fdefs                         {
    parseTree=new NodeSymbol();
    code.emit("HALT");
    }
;

fdefs : /* epsilon */                   {$$=new NodeSymbol();}
	| fdefs func_api {
                NodeFuncApi *func_api = dynamic_cast<NodeFuncApi*>($2);
                FunctionEntry* funcEntry = funcTable.find(func_api->funcProps.id);
                if(funcEntry != nullptr){
                    funcEntry = funcTable.insert(func_api->funcProps);
                } else { //found
                    if(!funcEntry->matchExisting(func_api->funcProps))
                        semantic_error("duplicate declaration of function with different API");
                    //override args to ensure correct arg naming
                    funcEntry->props.args = func_api->funcProps.args;
                }
                if(funcEntry->isDefined())
                    semantic_error("duplicate definition of a function");
                funcTable.setCurrent(funcEntry);
                funcEntry->define(code.nextQuad());
        } blk            {
                $$=new NodeSymbol();
                NodeStatement *blk = dynamic_cast<NodeStatement*>($3);

                if(!blk->breaklist.empty())
                    semantic_error("break statement not within loop");

                code.emit("RETRN"); //fallback, for when not defined
        }
        | fdefs func_api ';'            {
                $$=new NodeSymbol();
                NodeFuncApi *func_api = dynamic_cast<NodeFuncApi*>($2);

                FunctionEntry* funcEntry = funcTable.find(func_api->funcProps.id);
                if(funcEntry != nullptr){
                    funcTable.insert(func_api->funcProps);
                } else { //found
                    if(!funcEntry->matchExisting(func_api->funcProps)){
                        semantic_error("duplicate declaration of function with different API");
                    } 
                }
        }
;

func_api : type ID '(' func_args ')'    {
                $$ = new NodeFuncApi();
                NodeFuncApi* func_api = dynamic_cast<NodeFuncApi*>($$);
                NodeType *type = dynamic_cast<NodeType*>($1);
                NodeToken *id = dynamic_cast<NodeToken*>($2);
                NodeFuncArgs *func_args = dynamic_cast<NodeFuncArgs*>($4);

                FunctionProps funcProps = {
                    type->typeValue,
                    id->value,
                    func_args->argList
                };
                func_api->funcProps = funcProps;
            } 
;

func_args : func_arglist                {
                $$=new NodeFuncArgs();
                NodeFuncArgs *func_args = dynamic_cast<NodeFuncApi*>($$);
                NodeFuncArgs *func_arglist = dynamic_cast<NodeFuncArgs*>($1);

                func_args->argList = func_arglist->argList;
            }       
            | /* epsilon */             {$$=new NodeFuncArgs();}
;

func_arglist :  func_arglist ',' dcl    {
                $$=new NodeFuncArgs();
                NodeFuncArgs *func_arglist = dynamic_cast<NodeFuncArgs*>($$);
                NodeFuncArgs *func_arglist1 = dynamic_cast<NodeFuncArgs*>($1);
                NodeDeclaration *dcl = dynamic_cast<NodeDeclaration*>($3);

                func_arglist->argList = func_arglist1->argList;
                for(string id : dcl->idList) {
                    //check duplicate arg names
                    for(ArgDeclaration argIt : func_arglist->argList){
                        if(argIt.id == id)
                            semantic_error("Can't redecalre same variable name");
                    }
                    ArgDeclaration arg = {id, dcl->idType};
                    func_arglist->argList.push_back(arg);
                }
        } 
        | dcl                   {
                $$=new NodeFuncArgs();
                NodeFuncArgs *func_arglist = dynamic_cast<NodeFuncArgs*>($$);
                NodeDeclaration *dcl = dynamic_cast<NodeDeclaration*>($1);

                for(string id : dcl->idList){
                    ArgDeclaration arg= {id, dcl->idType};
                    func_arglist->argList.push_back(arg);
                }
        }
;

blk : '{'                             { 
                varTable.push();
                if(varTable.functionArgs.size() > 0){
                    for(ArgDeclaration arg : varTable.functionArgs){ //Place function args are in the first scope
                        varTable.front().newVar(arg.id, arg.type);
                    }
                    code.emit("ADD2I",SP,SP,varTable.functionArgs.size() * VAR_SIZE);
                    varTable.functionArgs.clear();
                }
        } 
        stlist '}'                    {
                $$=new NodeStatement();
                NodeStatement *blk = dynamic_cast<NodeStatement*>($$);
                NodeStatement *stlist = dynamic_cast<NodeStatement*>($1);

                blk->nextlist = stlist->nextlist;
                blk->breaklist = stlist->breaklist;
                varTable.pop();
                varTable.front().resetTmps();
        } 
;

dcl :   ID ':' type                     {
                $$=new NodeDeclaration();
                NodeDeclaration *dcl = dynamic_cast<NodeDeclaration*>($$);
                NodeToken *id = dynamic_cast<NodeToken*>($1);
                NodeType *type = dynamic_cast<NodeType*>($3);

                if(type->typeValue == eVOID)
                        semantic_error("variable can't be 'void'");
                
                dcl->idType = type->typeValue;
                dcl->idList.push_front(id->value);
                }
        | ID ',' dcl                    {
                $$=new NodeType();
                NodeDeclaration *dcl = dynamic_cast<NodeDeclaration*>($$);
                NodeToken *id = dynamic_cast<NodeToken*>($1);
                NodeDeclaration *dcl1 = dynamic_cast<NodeDeclaration*>($3);

                //Check if previously decalred same name
                if (std::find(std::begin(dcl1->idList), std::end(dcl1->idList), id->value) != std::end(dcl1->idList))
                    semantic_error("Can't redecalre same variable name");

                dcl->idType = dcl1->idType;
                dcl->idList = dcl1->idList;
                dcl->idList.push_front(id->value);
        }
;

type :  INT                             {
                $$=new NodeType();
                ((NodeType*)$$)->typeValue = eINT;
        }
        | FLOAT                         {
                $$=new NodeType();
                ((NodeType*)$$)->typeValue = eFLOAT;
        }
        | VOID                          {
                $$=new NodeType();
                ((NodeType*)$$)->typeValue = eVOID;
        }
;

stlist : stlist M stmt                    {
                $$=new NodeStatement();
                NodeStatement *stlist=$$;
                NodeStatement *stlist1=dynamic_cast<NodeStatement*>($1);
                NodeMarkerM *M=dynamic_cast<NodeMarkerM*>($2);
                NodeStatement *stmt=dynamic_cast<NodeStatement*>($3);

                code.backpatch(stlist1->nextlist, M->quad);
                stlist->nextlist.merge(stmt->nextlist);
                stlist->breaklist.merge(stmt->breaklist);
                stlist->breaklist.merge(stlist1->breaklist);
        }
         |/* epsilon */                 {$$=new NodeSymbol();}
;

stmt :  dcl ';'                         {
                $$=new NodeStatement();
                NodeDeclaration *dcl = dynamic_cast<NodeDeclaration*>($1);

                for(string id : dcl->idList){
                    // variable can't be declared twice in the same block
                    if(varTable.isInScope(id))
                        semantic_error("declaration of an already declared variable within the block");                     
                    varTable.front().newVar(id, dcl->idType);
                }
                code.emit("ADD2I",SP,SP,dcl->idList.size() * VAR_SIZE);
        }
        | assn                          {$$=new NodeStatement();}
        | exp ';'                       {$$=new NodeStatement();}
        | cntrl                         {
                $$=new NodeStatement();
                NodeStatement *stmt = dynamic_cast<NodeStatement*>($$);
                NodeStatement *cntrl = dynamic_cast<NodeStatement*>($1); 

                stmt->nextlist = cntrl->nextlist;
                stmt->breaklist = cntrl->breaklist;
        }
        | read                          {$$=new NodeStatement();}
        | write                         {$$=new NodeStatement();}
        | return                        {$$=new NodeStatement();}
        | blk                           {
                $$=new NodeStatement();
                NodeStatement *stmt = dynamic_cast<NodeStatement*>($$);
                NodeStatement *blk = dynamic_cast<NodeStatement*>($1);

                stmt->nextlist = blk->nextlist;
                stmt->breaklist = blk->breaklist;
                
        }
        | BREAK ';'                     {
                $$=new NodeStatement();
                NodeStatement *stmt = dynamic_cast<NodeStatement*>($$);

                stmt->breaklist.push_back(code.nextQuad());
                code.emit("UJUMP -1");
        }
;

return : RETURN exp ';'                 {
            $$=new NodeSymbol();
            NodeExpression *exp = dynamic_cast<NodeExpression*>($2);
            
            //check return type matches function's return type
            if(funcTable.getCurrent()->props.type != exp->expType)
                semantic_error("return value type isn't matching function's declaration");

            if(exp->expType == eVOID)
                semantic_error("return value type can't be void");

            //Store return value in "return register"
            if(exp->expType == eINT)
                code.emit("COPYI", RT_I, exp->place);
            else if(exp->expType == eFLOAT)
                code.emit("COPYF", RT_F, exp->place);

            code.emit("RETRN");
        }
        | RETURN ';'                    {
            $$=new NodeSymbol();

            if(funcTable.getCurrent()->props.type != eVOID)
                semantic_error("expected a return argument");

            code.emit("RETRN");
        }
;

write : WRITE '(' exp ')' ';'           {
                $$=new NodeSymbol();

                NodeExpression *exp = dynamic_cast<NodeExpression*>($3);
                
                if(exp->expType == eVOID)
                        semantic_error("can't assign/read void expressions");
                if(exp->expType == eINT)
                    code.emit("PRNTI", exp->place);
                else if(exp->expType == eFLOAT)
                    code.emit("PRNTF", exp->place);
                
                } 
        | WRITE '(' STR ')' ';'         {
                $$=new NodeSymbol();

                NodeToken *strToken = dynamic_cast<NodeToken*>($3);

                string str = strToken->value;
                for(int i=0; i<str.length();i++){
                    if(str[i] == '\\'){
                        i++;
                        switch(str[i]){
                            case 'n':
                                code.emit("PRNTC 10");
                                break;
                            case 't':
                                code.emit("PRNTC 9");
                                break;
                            case '"':
                                code.emit("PRNTC 34");
                                break;
                            default:
                                unexpected_error("Unknown char after \\");
                        }
                    } else {
                        code.emit("PRNTC", to_string(int(str[i])));
                    }
                }
        } 
;

read : READ '(' lval ')' ';'            {
                $$=new NodeSymbol();
                NodeSymbol *read = dynamic_cast<NodeSymbol*>($$);
                NodeExpression *lval = dynamic_cast<NodeExpression*>($3);
                
                // lval can't be void - it's guarrnteed at this point
                string type = (lval->expType == eINT) ? "I" : "F";
                string temp = varTable.front().newTemp(lval->expType);
                code.emit(string("READ")+type, temp);
                code.emit(string("STOR")+type, temp, lval->place, 0);
        } 
;

assn : lval ASSIGN exp ';'              {
                $$=new NodeStatement();
                NodeStatement *assn = dynamic_cast<NodeStatement*>($$);
                NodeExpression *lval = dynamic_cast<NodeExpression*>($1);
                NodeExpression *exp1 = dynamic_cast<NodeExpression*>($3);

                if(lval->expType != exp1->expType)
                        semantic_error("assignment of different types");
                // lval can't be void - it's guarrnteed at this point
                string type = (lval->expType == eINT) ? "I" : "F";

                code.emit(string("STOR")+type, exp1->place, lval->place, 0);
        } 
;

lval : ID                               {
                $$ = new NodeExpression();
                NodeExpression *lval = dynamic_cast<NodeExpression*>($$);
                NodeToken *id = dynamic_cast<NodeToken*>($1);
                
                // search ID in the symbol table (must have been declared)
                VarEntry idEntry;
                bool found = varTable.lookupVarTableList(idEntry, id->value);
                if(!found)
                    semantic_error("accessed undeclared variable");
                
                string addressReg = varTable.front().newTemp(eINT);
                code.emit("ADD2I",addressReg, DP, idEntry.offset);

                lval->expType = idEntry.type;
                lval->place = addressReg;
        }
;       

fullwhile : FULL_WHILE N M bexp DO M stmt {
                $$ = new NodeBexp();
                NodeBexp *fullwhile = dynamic_cast<NodeBexp*>($$);
                NodeMarkerN *N = dynamic_cast<NodeMarkerN*>($2);
                NodeMarkerM *M1 = dynamic_cast<NodeMarkerM*>($3);
                NodeBexp *bexp = dynamic_cast<NodeBexp*>($4);
                NodeMarkerM *M2 = dynamic_cast<NodeMarkerM*>($6);
                NodeStatement *stmt = dynamic_cast<NodeStatement*>($7);

                code.emit("UJUMP", M1->quad);
                code.backpatch(N->nextlist,code.nextQuad());
                string res = varTable.front().newTemp(eINT);
                code.emit("COPYI", res , "0"); 
                code.emit("UJUMP", M1->quad);
                code.backpatch(bexp->truelist,code.nextQuad());
                code.emit("COPYI", res , "1"); 
                code.emit("UJUMP", M2->quad);
                code.backpatch(bexp->falselist,code.nextQuad());
                fullwhile->falselist = CodeLineList(code.nextQuad());
                fullwhile->falselist.merge(stmt->breaklist);
                code.emit("BREQZ", res , "-1"); 
                fullwhile->truelist = CodeLineList(code.nextQuad());
                code.emit("UJUMP -1");
                code.backpatch(stmt->nextlist,M1->quad);
        } 
;

cntrl : IF bexp THEN M stmt ELSE N M stmt     {
                $$ = new NodeStatement();
                NodeStatement *cntrl = dynamic_cast<NodeStatement*>($$);
                NodeBexp *bexp = dynamic_cast<NodeBexp*>($2);
                NodeMarkerM *M1 = dynamic_cast<NodeMarkerM*>($4);
                NodeStatement *stmt1 = dynamic_cast<NodeStatement*>($5);
                NodeMarkerN *N = dynamic_cast<NodeMarkerN*>($7);
                NodeMarkerM *M2 = dynamic_cast<NodeMarkerM*>($8);
                NodeStatement *stmt2 = dynamic_cast<NodeStatement*>($9);
                
                code.backpatch(bexp->truelist, M1->quad);
                code.backpatch(bexp->falselist, M2->quad);
                cntrl->nextlist.merge(N->nextlist);
                cntrl->nextlist.merge(stmt1->nextlist);
                cntrl->nextlist.merge(stmt2->nextlist);
                cntrl->breaklist.merge(stmt1->breaklist);
                cntrl->breaklist.merge(stmt2->breaklist);
                
        } 
        | IF bexp THEN M stmt             {
                $$ = new NodeStatement();
                NodeStatement *cntrl = dynamic_cast<NodeStatement*>($$);
                NodeBexp *bexp = dynamic_cast<NodeBexp*>($2);
                NodeMarkerM *M = dynamic_cast<NodeMarkerM*>($4);
                NodeStatement *stmt = dynamic_cast<NodeStatement*>($5);
                
                code.backpatch(bexp->truelist, M->quad);
                cntrl->nextlist.merge(bexp->falselist);
                cntrl->nextlist.merge(stmt->nextlist);
                cntrl->breaklist.merge(stmt->breaklist);
        
        } 
        | WHILE M bexp DO M stmt            {
                $$ = new NodeStatement();
                NodeStatement *cntrl = dynamic_cast<NodeStatement*>($$);
                NodeMarkerM *M1 = dynamic_cast<NodeMarkerM*>($2);
                NodeBexp *bexp = dynamic_cast<NodeBexp*>($3);
                NodeMarkerM *M2 = dynamic_cast<NodeMarkerM*>($5);
                NodeStatement *stmt = dynamic_cast<NodeStatement*>($6);

                code.backpatch(bexp->truelist,M2->quad);
                code.backpatch(stmt->nextlist,M1->quad);
                cntrl->nextlist.merge(bexp->falselist);
                cntrl->nextlist.merge(stmt->breaklist);
                code.emit("UJUMP", M1->quad); //support "fall through" from stmt
        } 
        | fullwhile                     {
                $$ = new NodeStatement();
                NodeStatement *cntrl = dynamic_cast<NodeStatement*>($$);
                NodeBexp *fullwhile = dynamic_cast<NodeBexp*>($1);
                
                // fullwhile has truelist & falselist that in a case of cntrl statement both points on the same "goto line"  
                cntrl->nextlist.merge(fullwhile->truelist);
                cntrl->nextlist.merge(fullwhile->falselist);
        }
;

bexp :  bexp OR M bexp                  {
                $$ = new NodeBexp();
                NodeBexp *bexp = dynamic_cast<NodeBexp*>($$);
                NodeBexp *bexp1 = dynamic_cast<NodeBexp*>($1);
                NodeMarkerM *M = dynamic_cast<NodeMarkerM*>($3);
                NodeBexp *bexp2 = dynamic_cast<NodeBexp*>($4);
                
                code.backpatch(bexp1->falselist, M->quad);
                bexp->truelist.merge(bexp1->truelist);
                bexp->truelist.merge(bexp2->truelist);
                bexp->falselist.merge(bexp2->falselist);
        }
        | bexp AND M bexp               {
                $$ = new NodeBexp();
                NodeBexp *bexp = dynamic_cast<NodeBexp*>($$);
                NodeBexp *bexp1 = dynamic_cast<NodeBexp*>($1);
                NodeMarkerM *M = dynamic_cast<NodeMarkerM*>($3);
                NodeBexp *bexp2 = dynamic_cast<NodeBexp*>($4);
                
                code.backpatch(bexp1->truelist,M->quad);
                bexp->truelist.merge(bexp2->truelist);
                bexp->falselist.merge(bexp1->falselist);
                bexp->falselist.merge(bexp2->falselist);
        }
        | NOT bexp                      {
                $$ = new NodeBexp();
                NodeBexp *bexp = dynamic_cast<NodeBexp*>($$);        
                NodeBexp *bexp1 = dynamic_cast<NodeBexp*>($2);        

                bexp->falselist.merge(bexp1->truelist);
                bexp->truelist.merge(bexp1->falselist);
        }
        | exp RELOP exp                 {
                $$ = new NodeBexp();
                NodeBexp *bexp = dynamic_cast<NodeBexp*>($$);        
                NodeExpression *exp1 = dynamic_cast<NodeExpression*>($1);
                NodeToken *relop = dynamic_cast<NodeToken*>($2);
                NodeExpression *exp2 = dynamic_cast<NodeExpression*>($3);

                if(exp1->expType != exp2->expType)
                        semantic_error("RELOP between incompatible types");
                if(exp1->expType == eVOID)
                        semantic_error("RELOP can't be done with 'void'");                
                string type = (exp1->expType == eINT) ? "I" : "F"; 
                
                // calculate RELOP
                string res = varTable.front().newTemp(eINT);
                switch (RelopHit(relop->value)){
                case eEq:
                        code.emit(string("SEQU")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code.nextQuad());
                        code.emit("BNEQZ", res, "-1"); //expressions equal --> res=1 
                        break;
                case eNeq:
                        code.emit(string("SNEQ")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code.nextQuad());
                        code.emit("BNEQZ", res, "-1");
                        break;
                case eLt:
                        code.emit(string("SLET")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code.nextQuad());
                        code.emit("BNEQZ", res, "-1");
                        break;
                case eLtEq:
                        code.emit(string("SGRT")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code.nextQuad());
                        code.emit("BEQZ", res, "-1"); //exp1 <= exp2 --> res=0
                        break;
                case eGt:
                        code.emit(string("SGRT")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code.nextQuad());
                        code.emit("BNEQZ", res, "-1");
                        break;
                case eGtEq:
                        code.emit(string("SLET")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code.nextQuad());
                        code.emit("BEQZ", res, "-1"); //exp1 >= exp2 --> res=0
                        break;
                default:
                        unexpected_error("can't find RELOP match");
                        break;
                }       

                bexp->falselist.push_back(code.nextQuad());
                code.emit("UJUMP -1");
                
        }
        | '(' bexp ')'                  {
                $$ = new NodeBexp();
                NodeBexp *bexp = dynamic_cast<NodeBexp*>($$);        
                NodeBexp *bexp1 = dynamic_cast<NodeBexp*>($2);

                bexp->truelist = bexp1->truelist;        
                bexp->falselist = bexp1->falselist;        
        }
        | fullwhile                     {
                $$ = new NodeBexp();
                NodeBexp *fullwhile = dynamic_cast<NodeBexp*>($1);
                NodeBexp *bexp = dynamic_cast<NodeBexp*>($$);        

                bexp->truelist = fullwhile->truelist;        
                bexp->falselist = fullwhile->falselist;        
        }
;

exp :   exp ADDOP exp 	                {
                $$=new NodeExpression();
                NodeExpression *exp = dynamic_cast<NodeExpression*>($$);
                NodeExpression *exp1 = dynamic_cast<NodeExpression*>($1);
                NodeToken *addop = dynamic_cast<NodeToken*>($2);
                NodeExpression *exp2 = dynamic_cast<NodeExpression*>($3);

                if(exp1->expType != exp2->expType)
                        semantic_error("assignment of different types");
                if(exp1->expType == eVOID)
                        semantic_error("ADDOP can't be done with 'void'");
                
                string type = (exp1->expType == eINT) ? "I" : "F";
                // calculate ADDOP
                string res = varTable.front().newTemp(exp1->expType);
                switch (ArithHit(addop->value)){
                case eAdd:
                        code.emit(string("ADD2")+type, res, exp1->place, exp2->place);
                        break;
                case eNeq:
                        code.emit(string("SUBT")+type, res, exp1->place, exp2->place);
                        break;
                default:
                        unexpected_error("can't find ADDOP match");
                        break;
                }

                exp->expType = exp1->expType;
                exp->place = res;
        }
        | exp MULOP exp                 {
                $$=new NodeExpression();
                NodeExpression *exp = dynamic_cast<NodeExpression*>($$);
                NodeExpression *exp1 = dynamic_cast<NodeExpression*>($1);
                NodeToken *mulop = dynamic_cast<NodeToken*>($2);
                NodeExpression *exp2 = dynamic_cast<NodeExpression*>($3);

                if(exp1->expType != exp2->expType)
                        semantic_error("assignment of different types");
                if(exp1->expType == eVOID)
                        semantic_error("ADDOP can't be done with 'void'");
                
                string type = (exp1->expType == eINT) ? "I" : "F";
                // calculate MULOP
                string res = varTable.front().newTemp(exp1->expType);
                switch (ArithHit(mulop->value)){
                case eMul:
                        code.emit(string("MULT")+type, res, exp1->place, exp2->place);
                        break;
                case eDiv:
                        code.emit(string("DIVD")+type, res, exp1->place, exp2->place);
                        break;
                default:
                        unexpected_error("can't find ADDOP match");
                        break;
                }

                exp->expType = exp1->expType;
                exp->place = res;
        }
        | '(' exp ')'                   {
            $$=new NodeExpression();
            NodeExpression *exp = dynamic_cast<NodeExpression*>($$);
            NodeExpression *exp1 = dynamic_cast<NodeExpression*>($2);

            exp->place = exp1->place;
            exp->expType = exp1->expType;
        }
        | '(' type ')' exp              {
            $$=new NodeExpression();
            NodeExpression *exp = dynamic_cast<NodeExpression*>($$);
            NodeType *type = dynamic_cast<NodeType*>($2);
            NodeExpression *exp1 = dynamic_cast<NodeExpression*>($4);

            if(type->typeValue == exp1->expType){
                //No cast needed
                exp->place = exp1->place;
                exp->expType = exp1->expType;
            } else {
                if(type->typeValue == eVOID)
                    semantic_error("can't cast to void");
                if(exp1->expType == eVOID)
                    semantic_error("can't cast from void");
                if(type->typeValue == eINT){
                    exp->place = varTable.front().newTemp(eINT);
                    code.emit("CFTOI", exp->place, exp1->place);
                } else { //eFLOAT
                    exp->place = varTable.front().newTemp(eFLOAT);
                    code.emit("CITOF", exp->place, exp1->place);
                }
            }

        }
        | ID                            {
                $$=new NodeExpression();
                NodeExpression *exp = dynamic_cast<NodeExpression*>($$);
                NodeToken *id = dynamic_cast<NodeToken*>($1); 
                
                VarEntry idEntry;
                bool found = varTable.lookupVarTableList(idEntry, id->value);
                if(!found)
                    semantic_error("tried evaluating undeclared variable");

                string type = (idEntry.type == eINT) ? "I" : "F";
                string temp = varTable.front().newTemp(idEntry.type);
                code.emit(string("LOAD")+type, temp, DP, idEntry.offset);

                exp->expType = idEntry.type;
                exp->place = temp;
        }
        | num                           {
                $$=new NodeExpression();
                NodeExpression *exp = dynamic_cast<NodeExpression*>($$);
                NodeExpression *num = dynamic_cast<NodeExpression*>($1);

                exp->place = num->place;
                exp->expType = num->expType;
        }
        | call                          {
                $$=new NodeExpression();
                NodeExpression *exp = dynamic_cast<NodeExpression*>($$);
                NodeExpression *call = dynamic_cast<NodeExpression*>($1);

                exp->place = call->place;
                exp->expType = call->expType;
        }
;

num :   INTEGERNUM                      {
                $$=new NodeExpression();
                NodeExpression *num = dynamic_cast<NodeExpression*>($$);
                NodeToken *integer = dynamic_cast<NodeToken*>($1);

                num->place = varTable.front().newTemp(eINT);
                num->expType = eINT;
                code.emit("COPYI", num->place , integer->value); 
        }
        | REALNUM                       {
                $$=new NodeExpression();
                NodeExpression *num = dynamic_cast<NodeExpression*>($$);
                NodeToken *real = dynamic_cast<NodeToken*>($1);

                num->place = varTable.front().newTemp(eFLOAT);
                num->expType = eFLOAT;
                code.emit("COPYF", num->place , real->value); 
        }
;

call : ID '(' call_args ')'             {
        $$=new NodeExpression();
        NodeExpression *call = dynamic_cast<NodeExpression*>($$);
        NodeToken *id = dynamic_cast<NodeToken*>($1);
        NodeCallArgs *call_args = dynamic_cast<NodeCallArgs*>($3);

        FunctionEntry* funcEntry = funcTable.find(id->value);
        if(funcEntry == nullptr)
            semantic_error("called an undeclared function");
        if(call_args->exprList.size() != funcEntry->props.args.size())
            semantic_error("wrong number of arguments passed to function");

        varTable.storeIds(); //for each var: Mem[SP++] = var
        code.emit("STORI", RA, SP, 0); //Mem[SP] = RA
        code.emit("STORI", DP, SP, 1); //Mem[SP+1] = DP
        code.emit("STORI", FP, SP, 2); //Mem[SP+2] = FP

        code.emit("ADD2I", FP, SP, 2);
        //store arguments
        int i = FUNC_ARGS_OFFSET;
        auto argIt = funcEntry->props.args.begin(), expArg = call_args->expList.begin();
        for(;argIt != funcEntry->props.args.end();i++, argIt++, expArg++){
            if(expArg->expType != argIt->type)
                semantic_error("wrong type of argument passed to function");

            string type = (argIt->type == eINT) ? "I" : "F";
            code.emit(string("STOR")+type, expArg->place, FP, i);
            i++;
        }
        //set SP below arguments
        code.emit("ADD2I", SP, FP, funcEntry->props.args.size()+FUNC_ARGS_OFFSET);
        code.emit("COPYI", DP, SP);

        //jump
        string L = funcEntry->getPlace(code.nextQuad());
        code.emit("JLINK", L);
        
        //return from callee
        
        //restore SP, FP
        code.emit("COPYI", SP, FP); //SP = FP
        code.emit("LOADI", FP, FP); //Mem[SP+1] = FP
        code.emit("SUBTI", SP, 2); //SP-=2 
        code.emit("LOADI", RA, SP, 0); //RA = Mem[SP]
        code.emit("LOADI", RA, SP, 1); //DP = Mem[SP+1]
        varTable.loadIds();  //for each var: var = Mem[--SP]
        

        call->expType = funcEntry->props.type;
        //store the return value, non-void return value
        if(funcEntry->props.type == eINT){
                call->place = varTable.front().newTemp(eINT);
                code.emit("COPYI", call->place, RT_I);
        } else if(funcEntry->props.type == eFLOAT){
                call->place = varTable.front().newTemp(eFLOAT);
                code.emit("COPYF", call->place, RT_F);
        }
}
;

call_args : call_arglist                {
                $$=new NodeCallArgs();
                NodeCallArgs *call_args = dynamic_cast<NodeCallArgs*>($$);
                NodeCallArgs *call_arglist = dynamic_cast<NodeCallArgs*>($1);

                call_args->exprList = call_arglist->exprList;
            }
            |/* epsilon */              {$$=new NodeSymbol();} 
;

call_arglist :  call_arglist ',' exp    {
                $$=new NodeCallArgs();
                NodeCallArgs *call_arglist = dynamic_cast<NodeCallArgs*>($$);
                NodeCallArgs *call_arglist1 = dynamic_cast<NodeCallArgs*>($1);
                NodeExpression *exp = dynamic_cast<NodeExpression*>($3);
                
                if(exp->expType == eVOID)
                    semantic_error("can't pass argument of type 'void' to a function");
                call_arglist->exprList = call_arglist1->exprList;
                call_arglist->exprList.push_back(*exp);
        }
        | exp                           {
                $$=new NodeCallArgs();
                NodeCallArgs *call_arglist = dynamic_cast<NodeCallArgs*>($$);
                NodeExpression *exp = dynamic_cast<NodeExpression*>($1);

                if(exp->expType == eVOID)
                    semantic_error("can't pass argument of type 'void' to a function");
                call_arglist->exprList.push_back(*exp);
        }
;

M : /*epsilon*/                         {$$=new NodeMarkerM();}
;

N : /*epsilon*/                         {$$=new NodeMarkerN();}
;

%%

void unexpected_error(const char* err){
    cerr << err << endl;
    exit(10);
}

void semantic_error(const char* err){
    cerr << "Semantic error: " << err << "in line number " << yylineno <<endl;
    exit(3);
}

void yyerror(const char*) {
    cerr << "Syntax error: '" << yytext << "' in line number " << yylineno << endl;
    exit(2);
}
