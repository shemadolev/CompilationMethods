%{
    #include <iostream>
    #include "part2_helpers.hpp"
    #include "code_class.hpp"
    #include "symbol_table.hpp"

    using namespace std;

    extern int yylex();
    void yyerror(const char*);
    void unexpected_error(const char*);

    extern int yylineno;
    extern const char* yytext;

    ParserNode *parseTree; 
    codeClass code;
    VarScopeTable *varScopeTable;

    //return address pointer
    #define $RA "I0"
    //frame start pointer
    #define $FP "I1"
    //stack pointer (next write pointer in stack)
    #define $SP "I2"
    //return int type
    #define $RT_I "I3"
    //return float type
    #define $RT_F "F0"
%}

// Reserved words 
%token  INT
        FLOAT
        VOID
        WRITE
        READ
        WHILE
        DO
        IF
        RETURN
        FULL_WHILE
        BREAK

// Solve dangling else (select shift over reduce)  
%precedence THEN
%precedence ELSE

// Other tokens (no special precedence)
%token ID INTEGERNUM REALNUM STR

//Associativity & precedence matched to C++ syntax
%right ASSIGN
%left OR
%left AND
%left RELOP
%left ADDOP
%left MULOP
%right NOT

// Symbols (Highest priority)
%precedence '(' ')' '{' '}' '.' ';' ',' ':'

%%

program : fdefs                         {parseTree=new NodeSymbol("PROGRAM",$1);}
;

fdefs : /* epsilon */                   {$$=new NodeSymbol("FDEFS", EPSILON);}
	| fdefs func_api M blk            {
                $$=new NodeSymbol("FDEFS",concatList(concatList($1,$2),$3));
                //todo - backpatch all callers
        }
        | fdefs func_api ';'            {$$=new NodeSymbol("FDEFS",concatList(concatList($1,$2),$3));}
;

func_api : type ID '(' func_args ')'    {$$=new NodeSymbol("FUNC_API",concatList(concatList(concatList(concatList($1,$2),$3),$4),$5));} 
;

func_args : func_arglist                {$$=new NodeSymbol("FUNC_ARGS",$1);}       
            | /* epsilon */             {$$=new NodeSymbol("FUNC_ARGS", EPSILON);}
;

func_arglist :  func_arglist ',' dcl    {$$=new NodeSymbol("FUNC_ARGLIST",concatList(concatList($1,$2),$3));} 
                | dcl                   {$$=new NodeSymbol("FUNC_ARGLIST",$1);}
;

blk : '{' stlist '}'                    {$$=new NodeSymbol("BLK",concatList(concatList($1,$2),$3));} 
;

dcl :   ID ':' type                     {$$=new NodeSymbol("DCL",concatList(concatList($1,$2),$3));}
        | ID ',' dcl                    {$$=new NodeSymbol("DCL",concatList(concatList($1,$2),$3));}
;

type :  INT                             {
                $$=new NodeType("TYPE",$1);
                $$->typeValue = eINT;
        }
        | FLOAT                         {
                $$=new NodeType("TYPE",$1);
                $$->typeValue = eFLOAT;
        }
        | VOID                          {
                $$=new NodeType("TYPE",$1);
                $$->typeValue = eVOID;
        }
;

stlist : stlist stmt                    {$$=new NodeSymbol("STLIST",concatList($1,$2));}
         |/* epsilon */                 {$$=new NodeSymbol("STLIST", EPSILON);}
;

stmt :  dcl ';'                         {$$=new NodeSymbol("STMT",concatList($1,$2));}
        | assn                          {$$=new NodeSymbol("STMT",$1);}
        | exp ';'                       {$$=new NodeSymbol("STMT",concatList($1,$2));}
        | cntrl                         {$$=new NodeSymbol("STMT",$1);}
        | read                          {$$=new NodeSymbol("STMT",$1);}
        | write                         {$$=new NodeSymbol("STMT",$1);}
        | return                        {$$=new NodeSymbol("STMT",$1);}
        | blk                           {$$=new NodeSymbol("STMT",$1);}
        | BREAK ';'                     {$$=new NodeSymbol("STMT",concatList($1,$2));}
;

return : RETURN exp ';'                 {
            $$=new NodeSymbol("RETURN",concatList(concatList($1,$2),$3));
            
            NodeExpression *exp = $2;

            //Store return value in "return register"
            if(exp->expType == eINT)
                code->emit("COPYI", $RT_I, exp->place);
            else if(exp->expType == eFLOAT)
                code->emit("COPYF", $RT_F, exp->place);

            //todo set $SP and $FP according to ABI

            }
        | RETURN ';'                    {
            $$=new NodeSymbol("RETURN",concatList($1,$2));

            //todo set $SP and $FP according to ABI
            }
;

write : WRITE '(' exp ')' ';'           {
                $$=new NodeSymbol("WRITE",concatList(concatList(concatList(concatList($1,$2),$3),$4),$5));

                NodeExpression *exp = $3;
                //TODO: what about void exp? --> semantic_error?
                if(exp->expType == eINT)
                    code->emit("PRNTI", exp->place);
                else if(exp->expType == eFLOAT)
                    code->emit("PRNTF", exp->place);
                
                } 
        | WRITE '(' STR ')' ';'         {
                $$=new NodeSymbol("WRITE",concatList(concatList(concatList(concatList($1,$2),$3),$4),$5));

                NodeToken *strToken = $3;

                string str = strToken->value;
                for(int i=0; i<str.length();i++){
                    if(str[i] == '\\'){
                        i++;
                        switch(str[i]){
                            case 'n':
                                code->emit("PRNTC 10");
                                break;
                            case 't':
                                code->emit("PRNTC 9");
                                break;
                            case '"':
                                code->emit("PRNTC 34");
                                break;
                            default:
                                unexpected_error("Unknown char after \\");
                        }
                    } else {
                        code->emit("PRNTC", to_string(int(str[i])));
                    }
                }
        } 
;

read : READ '(' lval ')' ';'            {
                NodeStatement *read = $$;
                NodeExpression *lval = $3;
                
                read=new NodeStatement("READ",concatList(concatList(concatList(concatList($1,$2),$3),$4),$5));

                // lval can't be void - it's guarrnteed at this point
                string type = (lval->expType == eINT) ? "I" : "F";
                code->emit(string("COPY")+type, lval->place, exp->place);                
        } 
;

assn : lval ASSIGN exp ';'              {
                NodeStatement *assn = $$;
                NodeExpression *lval = $1;
                NodeExpression *exp1 = $3;
                
                // assn is a stmt with an empty nextlist
                assn=new NodeStatement("ASSN",concatList(concatList(concatList($1,$2),$3),$4));

                if(lval->expType != exp->expType)
                        semantic_error("Assignment of different types");

                // lval can't be void - it's guarrnteed at this point
                string type = (lval->expType == eINT) ? "I" : "F";
                code->emit(string("COPY")+type, lval->place, exp->place);
        } 
;

lval : ID                               {
                NodeExpression *lval = $$;
                NodeToken *id = $1;
                
                lval = new NodeExpression("LVAL",id);
                
                // search ID in the symbol table (must have been declared)
                varEntry idEntry;
                bool found = VarScopeTable->getVar(id->value);
                if(!found)
                        semantic_error("Accessed undeclared variable");
                if(lval->expType == eVOID)
                        semantic_error("Can't assign/read void expressions");

                lval->expType = idEntry->type;
                lval->place = place;
        }
;       

fullwhile : FULL_WHILE N M bexp DO M stmt {
                NodeBexp *fullwhile = $$;
                NodeMarkerN *N = $2;
                NodeMarkerM *M1 = $3;
                NodeBexp *bexp = $4;
                NodeMarkerM *M2 = $6;
                NodeStatement *stmt = $7;
                
                fullwhile = new NodeBexp("FULLWHILE",concatList(concatList(concatList($1,$2),$3),$4));

                code->emit("UJUMP", M1->quad);
                code->backpatch(N->nextlist,code->nextQuad());
                string res = varScopeTable->newTemp(eINT);
                code->emit("COPYI", res , "0"); 
                code->emit("UJUMP", M1->quad);
                code->backpatch(bexp->truelist,code->nextQuad());
                code->emit("COPYI", res , "1"); 
                code->emit("UJUMP", M2->quad);
                code->backpatch(bexp->falselist,code->nextQuad());
                fullwhile->falselist = CodeLineList(code->nextQuad());
                fullwhile->falselist.merge(stmt->breaklist);
                code->emit("BREQZ", res , "-1"); 
                fullwhile->truelist = CodeLineList(code->nextQuad());
                code->emit("UJUMP -1");
                code->backpatch(stmt->nextlist,M1->quad);
        } 
;

cntrl : IF bexp THEN M stmt N ELSE M stmt     {
                NodeStatement *cntrl = $$;
                NodeBexp *bexp = $2;
                NodeMarkerM *M1 = $4;
                NodeBexp *stmt1 = $5;
                NodeMarkerN *N = $6;
                NodeMarkerM *M2 = $8;
                NodeBexp *stmt2 = $9;
                
                cntrl = new NodeStatement("CNTRL",concatList(concatList(concatList(concatList(concatList($1,$2),$3),$4),$5),$6));
                
                code->backpatch(bexp->truelist, M1->quad);
                code->backpatch(bexp->falselist, M2->quad);
                cntrl->nextlist.merge(N->nextlist);
                cntrl->nextlist.merge(stmt1->nextlist);
                cntrl->nextlist.merge(stmt2->nextlist);
                
        } 
        | IF bexp THEN M stmt             {
                NodeStatement *cntrl = $$;
                NodeBexp *bexp = $2;
                NodeMarkerM *M = $4;
                NodeBexp *stmt = $5;
                
                cntrl = new NodeStatement("CNTRL",concatList(concatList(concatList($1,$2),$3),$4));
                
                code->backpatch(bexp->truelist, M->quad);
                cntrl->nextlist.merge(bexp->falselist);
                cntrl->nextlist.merge(stmt->nextlist);
        
        } 
        | WHILE M bexp DO M stmt            {
                NodeStatement *cntrl = $$;
                NodeMarkerM *M1 = $2;
                NodeBexp *bexp = $3;
                NodeMarkerM *M2 = $5;
                NodeStatement *stmt = $6;

                cntrl = new NodeStatement("CNTRL",concatList(concatList(concatList($1,$2),$3),$4));

                code->backpatch(bexp->truelist,M2->quad);
                code->backpatch(stmt->nextlist,M1->quad);
                cntrl->nextlist.merge(bexp->falselist);
                code->emit("UJUMP", M1->quad); //support "fall through" from stmt
        } 
        | fullwhile                     {
                NodeStatement *cntrl = $$;
                NodeBexp *fullwhile = $1;
                
                fullwhile = new NodeStatement("CNTRL",$1);
                
                // fullwhile has truelist & falselist that in a case of cntrl statement both points on the same "goto line"  
                cntrl->nextlist.merge(fullwhile->truelist);
                cntrl->nextlist.merge(fullwhile->falselist);
        }
;

bexp :  bexp OR M bexp                  {
                NodeBexp *bexp = $$;
                NodeBexp *bexp1 = $1;
                NodeMarkerM *M = $3;
                NodeBexp *bexp2 = $4;
        
                bexp = new NodeBexp("BEXP",concatList(concatList($1,$2),$3));
                
                code->backpatch(bexp1->falselist, M->quad);
                bexp->truelist.merge(bexp1->truelist);
                bexp->truelist.merge(bexp2->truelist);
                bexp->falselist.merge(bexp2->falselist);
        }
        | bexp AND M bexp               {
                NodeBexp *bexp = $$;
                NodeBexp *bexp1 = $1;
                NodeMarkerM *M = $3;
                NodeBexp *bexp2 = $4;
                
                bexp = new NodeBexp("BEXP",concatList(concatList($1,$2),$3));
                
                code->backpatch(bexp1->truelist,M->quad);
                bexp->truelist.merge(bexp2->truelist);
                bexp->falselist.merge(bexp1->falselist);
                bexp->falselist.merge(bexp2->falselist);
        }
        | NOT bexp                      {
                NodeBexp *bexp = $$;        
                NodeBexp *bexp1 = $2;        
                
                bexp = new NodeBexp("BEXP",concatList($1,$2));

                bexp->falselist.merge(bexp1->truelist);
                bexp->truelist.merge(bexp1->falselist);
        }
        | exp RELOP exp                 {
                NodeBexp *bexp = $$;        
                NodeExpression *exp1 = $1;
                NodeExpression *exp1 = $3;

                if(exp1->expType != exp2->expType)
                        semantic_error("RELOP between incompatible types");                
                string type = (exp1->expType == eINT) ? "I" : "F"; 

                bexp = new NodeBexp("BEXP",concatList(concatList($1,$2),$3));
                
                // calculate RELOP
                string res = varScopeTable->newTemp(eINT);
                switch (RelopHit($1->value)){
                case eEq:
                        code->emit(string("SEQU")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code->nextQuad());
                        code->emit("BNEQZ", res, "-1"); //expressions equal --> res=1 
                        break;
                case eNeq:
                        code->emit(string("SNEQ")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code->nextQuad());
                        code->emit("BNEQZ", res, "-1");
                        break;
                case eLt:
                        code->emit(string("SLET")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code->nextQuad());
                        code->emit("BNEQZ", res, "-1");
                        break;
                case eLtEq:
                        code->emit(string("SGRT")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code->nextQuad());
                        code->emit("BEQZ", res, "-1"); //exp1 <= exp2 --> res=0
                        break;
                case eGt:
                        code->emit(string("SGRT")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code->nextQuad());
                        code->emit("BNEQZ", res, "-1");
                        break;
                case eGtEq:
                        code->emit(string("SLET")+type, res, exp1->place, exp2->place);
                        bexp->truelist.push_back(code->nextQuad());
                        code->emit("BEQZ", res, "-1"); //exp1 >= exp2 --> res=0
                        break;
                default:
                        break;
                }       

                bexp->falselist.push_back(code->nextQuad());
                code->emit("UJUMP -1");
                
        }
        | '(' bexp ')'                  {
                NodeBexp *bexp = $$;        
                NodeBexp *bexp1 = $2;
                
                bexp = new NodeBexp("BEXP",concatList(concatList($1,$2),$3));

                bexp->truelist = bexp1->truelist;        
                bexp->falselist = bexp1->falselist;        
        }
        | fullwhile                     {
                NodeBexp *fullwhile = $1;
                NodeBexp *bexp = $$;        
                
                bexp = new NodeBexp("BEXP",$1);

                bexp->truelist = fullwhile->truelist;        
                bexp->falselist = fullwhile->falselist;        
        }
;

exp :   exp ADDOP exp 	                {$$=new NodeExpression("EXP",concatList(concatList($1,$2),$3));}
        | exp MULOP exp                 {$$=new NodeExpression("EXP",concatList(concatList($1,$2),$3));}
        | '(' exp ')'                   {
            $$=new NodeExpression("EXP",concatList(concatList($1,$2),$3));
            NodeExpression *exp = $$;
            NodeExpression *exp1 = $2;

            exp->place = exp1->place;
            exp->expType = exp1->expType;
        }
        | '(' type ')' exp              {
            $$=new NodeExpression("EXP",concatList(concatList(concatList($1,$2),$3),$4));
            NodeExpression *exp = $$;
            NodeType *type = $2;
            NodeExpression *exp1 = $4;

            if(type->typeValue == eVOID)
                semantic_error("can't cast to void");
            if(exp1->expType == eVOID)
                semantic_error("can't cast from void");

            if(type->typeValue == exp1->expType){
                //No cast needed
                exp->place = exp1->place;
                exp->expType = exp1->expType;
            } else {
                if(type->typeValue == eINT){
                    exp->place = varScopeTable->newTemp(eINT);
                    code->emit("CFTOI", exp->place, exp1->place);
                } else { //eFLOAT
                    exp->place = varScopeTable->newTemp(eFLOAT);
                    code->emit("CITOF", exp->place, exp1->place)
                }
            }

        }
        | ID                            {
                $$=new NodeExpression("EXP",$1);
                NodeExpression *exp = $$;
                NodeToken *id = $1; 
                
                varEntry idVar;
                bool found = varScopeTable->getVar(idVar, id->value);
                if(!found)
                    semantic_error("tried evaluating undeclared variable");
                exp->expType = idVar.type;
                exp->place = idVar.place;
        }
        | num                           {
                $$=new NodeExpression("EXP",$1);
                NodeExpression *exp = $$;
                NodeExpression *num = $1;

                exp->place = num->place;
                exp->expType = num->expType;
        }
        | call                          {
                $$=new NodeExpression("EXP",$1);
                NodeExpression *exp = $$;
                NodeExpression *call = $1;

                exp->place = call->place;
                exp->expType = call->expType;
        }
;

num :   INTEGERNUM                      {
                $$=new NodeExpression("NUM",$1);
                NodeExpression *num = $$;

                num->place = varScopeTable->newTemp(eINT);
                num->expType = eINT;
        }
        | REALNUM                       {
                $$=new NodeExpression("NUM",$1);
                NodeExpression *num = $$;

                num->place = varScopeTable->newTemp(eFLOAT);
                num->expType = eFLOAT;
        }
;

call : ID '(' call_args ')'             {
        $$=new NodeExpression("CALL",concatList(concatList(concatList($1,$2),$3),$4));
        //...
        // 
        varScopeTable->storeIds();
        //Back FP
        //Pass arguments to function
        //...
        varScopeTable->loadIds();
        //...
        //Pass place & type of return value to 'call' Node
        }
;

call_args : call_arglist                {$$=new NodeSymbol("CALL_ARGS",$1);}
            |/* epsilon */              {$$=new NodeSymbol("CALL_ARGS", EPSILON);} 
;

call_arglist :  call_arglist ',' exp    {
                $$=new NodeArgsList("CALL_ARGLIST",concatList(concatList($1,$2),$3));
                $$->argsList = $1->argsList;
                $$->argsList.push_back(exp);
        }
        | exp                           {
                $$=new NodeArgsList("CALL_ARGLIST",$1);
                $$->argsList.push_back(exp);
        }
;

M : /*epsilon*/                         {$$=new NodeMarkerM();}
;

N : /*epsilon*/                         {$$=new NodeMarkerN();}
;

%%

void unexpected_error(const char* err){
    cout << err << endl;
    exit(10);
}

void operational_error(const char* err){
    cout << "Operational error: " << err <<endl;
    exit(9);
}

void semantic_error(const char* err){
    cout << "Semantic error: " err << "in line number " yylineno <<endl;
    exit(3)
}

void yyerror(const char*) {
    cout << "Syntax error: '" << yytext << "' in line number " << yylineno << endl;
    exit(2);
}